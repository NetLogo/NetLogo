// (C) Uri Wilensky. https://github.com/NetLogo/NetLogo(UTF8)

package org.nlogo.javafx

import java.awt.geom.AffineTransform
import java.awt.image.{ AffineTransformOp, BufferedImage }

import javafx.scene.canvas.GraphicsContext
import javafx.scene.text.{ Font, Text }
import javafx.embed.swing.SwingFXUtils

import org.nlogo.api.{ FontMetrics, GraphicsInterface => ApiGraphicsInterface }

class GraphicsInterface(context: GraphicsContext) extends ApiGraphicsInterface {
  // TODO: I believe scale is correcting for the size ratio of Shape.Width. I'm not sure context.scale accounts for this properly...
  def antiAliasing(on: Boolean): Unit = { }
  def dispose(): Unit = { }

  def draw(shape: java.awt.Shape): Unit = ???

  def drawCircle(x: Double,y: Double,xDiameter: Double,yDiameter: Double,scale: Double,angle: Double): Unit = {
    // need scale, angle...
    // println(s"drawing circle: ($x, $y) w: $xDiameter, h: $yDiameter, scale: $scale, angle: $angle")
    context.strokeOval(x, y, xDiameter, yDiameter)
  }

  // the image this takes is generated by TrailDrawer. Maybe it makes sense to have it create
  // a JavaFX image instead?
  def drawImage(image: java.awt.Image,x: Int,y: Int,width: Int,height: Int): Unit = {
    // println("drawing image")
    image match {
      case bufferedImage: BufferedImage =>
        val xform = new AffineTransform()
        xform.setToScale(
          width.toDouble  / bufferedImage.getWidth.toDouble,
          height.toDouble / bufferedImage.getHeight.toDouble)

        val xformOp = new AffineTransformOp(xform, AffineTransformOp.TYPE_NEAREST_NEIGHBOR)

        val destImage = new BufferedImage(width, height, bufferedImage.getType)
        xformOp.filter(bufferedImage, destImage)

        val fxImage = SwingFXUtils.toFXImage(destImage, null)
        context.drawImage(fxImage, x, y, width, height)
      case _ =>
    }
  }

  def drawImage(image: java.awt.image.BufferedImage): Unit = ???

  def drawLabel(s: String,x: Double,y: Double,patchSize: Double): Unit = {
    // TODO: this should be adjusted for max ascent / descent
    context.fillText(s, 0, 0)
  }
  def drawLine(x1: Double,y1: Double,x2: Double,y2: Double): Unit = {
    // println(s"drawing line: ($x1, $y1) ($x2, $y2)")
    context.strokeLine(x1, y1, x2, y2)
  }

  def drawPolygon(xcors: Array[Int],ycors: Array[Int],length: Int): Unit = {
    context.strokePolygon(
      xcors.map(_.toDouble).toArray[Double],
      ycors.map(_.toDouble).toArray[Double],
      length)
  }
  def drawPolyline(xcors: Array[Int],ycors: Array[Int],length: Int): Unit = {
    // println(s"drawing polyline")
    context.strokePolyline(
      xcors.map(_.toDouble).toArray[Double],
      ycors.map(_.toDouble).toArray[Double],
      length)
  }

  def drawRect(x: Double,y: Double,width: Double,height: Double,scale: Double,angle: Double): Unit = {
    context.strokeRect(x, y, width, height)
  }


  def fill(shape: java.awt.Shape): Unit = {
    // println(s"filling arbitrary shape")
    ???
  }

  def fillCircle(x: Double,y: Double,xDiameter: Double,yDiameter: Double,scale: Double,angle: Double): Unit = {
    // println(s"filling circle: ($x, $y) w: $xDiameter, h: $yDiameter, scale: $scale, angle: $angle")
    context.fillOval(x, y, xDiameter, yDiameter)
  }
  def fillPolygon(xcors: Array[Int],ycors: Array[Int],length: Int): Unit = {
    // println(s"filling polygon")
    context.fillPolygon(
      xcors.map(_.toDouble).toArray[Double],
      ycors.map(_.toDouble).toArray[Double],
      length)
  }
  def fillRect(x: Double,y: Double,width: Double,height: Double,scale: Double,angle: Double): Unit = {
    // println(s"filling rect ($x, $y), w: $width, h: $height, scale: $scale, angle: $angle ")
    context.fillRect(x, y, width, height)
  }
  def fillRect(x: Int,y: Int,width: Int,height: Int): Unit = {
    // println(s"filling rect ($x, $y), w: $width, h: $height")
    context.fillRect(x, y, width, height)
  }


  class FontMetricsWrapper(font: Font) extends FontMetrics {
    val text = new Text("")
    text.setFont(font)
    def stringWidth(s: String): Int = {
      text.setText(s)
      text.getLayoutBounds.getWidth.toInt
    }
    def getHeight(s: String): Int = {
      text.setText(s)
      text.getLayoutBounds.getHeight.toInt
    }
  }
  def getFontMetrics: FontMetrics =
    new FontMetricsWrapper(context.getFont)

  def location(x: Double,y: Double): String = {
    s"(${context.getTransform.getTx + x} , ${context.getTransform.getTy + y})"
  }
  def pop(): Unit = {
    // println("pop")
    // TODO: This should also restore strokes saved by the push method
    context.restore()
  }
  def push(): Unit = {
    // println("push")
    context.save()
    // TODO: This should also save strokes set with the setStroke methods
  }
  def rotate(theta: Double,x: Double,y: Double,offset: Double): Unit = {
    // println(s"rotation: $theta ($x, $y) @ offset $offset")
    rotate(theta, x + offset / 2, y + offset / 2)
  }
  def rotate(theta: Double,x: Double,y: Double): Unit = {
    // println(s"rotate: $theta ($x, $y)")
    import javafx.scene.transform.{ Affine, Transform }
    context.transform(new Affine(Transform.rotate(theta * 180 / StrictMath.PI, x, y)))
  }
  def rotate(theta: Double): Unit = {
    // println(s"rotating: $theta")
    context.rotate(theta * 180 / StrictMath.PI)
  }
  def scale(x: Double,y: Double,shapeWidth: Double): Unit = {
    // println(s"setting scale: ($x, $y) ($shapeWidth)")
    context.scale(x / shapeWidth, y / shapeWidth)
  }
  def scale(x: Double,y: Double): Unit = {
    // println(s"setting scale: ($x, $y)")
    context.scale(x, y)
  }

  def setColor(c: java.awt.Color): Unit = {
    // println(s"setting color: $c")
    val jfxColor =
      javafx.scene.paint.Color.rgb(c.getRed, c.getGreen, c.getBlue)
    context.setStroke(jfxColor)
    context.setFill(jfxColor)
  }

  def setComposite(comp: java.awt.Composite): Unit = {
    // TODO: I'm not sure whether this is necessary and/or possible in JavaFX
  }
  def setInterpolation(): Unit = {
    // TODO: I'm not sure whether this is necessary and/or possible in JavaFX
  }
  def setStroke(width: Float,dashes: Array[Float]): Unit = {
    // println(s"setting stroke $width, dashes: ${dashes.mkString(", ")}")
    // also should set line cap, color
    context.setLineWidth(width)
    context.setLineDashes(dashes.map(_.toDouble): _*)
  }
  def setStroke(width: Double): Unit = {
    // println(s"setting stroke $width")
    context.setLineWidth(width max 1.0)
    context.setLineDashes(1.0, 0.0)
  }
  def setStrokeControl(): Unit = {
    // TODO: Rendering hints about stroke
  }
  def setStrokeFromLineThickness(lineThickness: Double,scale: Double,cellSize: Double,shapeWidth: Double): Unit = {
    // println(s"setting stroke from line thickness $lineThickness")
    setStroke((shapeWidth / scale) * (if (lineThickness == 0) 1 else (lineThickness * cellSize)))
  }
  def translate(x: Double,y: Double): Unit = {
    context.translate(x, y)
  }
}

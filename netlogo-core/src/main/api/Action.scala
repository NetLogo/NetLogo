// (C) Uri Wilensky. https://github.com/NetLogo/NetLogo

package org.nlogo.api

import org.nlogo.core.{ Listener, Publisher }

import scala.collection.mutable.ArrayBuffer
import scala.concurrent.{ Await, ExecutionContext, Future }
import scala.concurrent.duration.Duration

trait Action

trait ActionRunner[A <: Action] {
  def run(action: A): Unit
}

trait ActionBroker[A <: Action] extends Publisher[A] {
  val runner: ActionRunner[A]

  // some actions can be quite slow to prepare and execute, so they are first marked as incoming,
  // then prepared and published on a background thread. this reduces unnecessary computation up front,
  // passing the work on to `grab` if it is called before a relevant background thread has completed.
  // (Isaac B 12/12/25)
  private var incoming = Set[Future[A]]()

  override def publish(action: A): Unit = {
    super.publish(action)
    runner.run(action)
  }

  /**
   * Normally, you would not want to do that. The one use case we
   * have is the Stamp drawing action which, when recorded through
   * an ActionBroker, calls trailDrawer.stamp() directly and grabs
   * a bitmap that will be stored in the Action. No need, then, to
   * re-import that bitmap through the runner. But this is very much
   * a hack and I wish we had another way of handling stamping so we
   * could (amongst other things) get rid of this method. NP 2013-02-04
   */
  def publishWithoutRunning(action: A): Unit = {
    super.publish(action)
  }

  def publishIncomingWithoutRunning(future: Future[A]): Unit = {
    incoming += future
  }

  def waitForIncoming(): Unit = {
    implicit val ec: ExecutionContext = ExecutionContext.global

    Await.result(Future.sequence(incoming), Duration.Inf).foreach(super.publish)

    incoming = Set()
  }
}

/**
 * An ActionBuffer logs all actions generated by the supplied
 * ActionBroker. Actions can be grabbed (which clears the buffer)
 * and the buffer can be cleared independently. NP 2013-01-25.
 */
class ActionBuffer[A <: Action](broker: ActionBroker[A]) extends Listener[A] {
  private val buffer = ArrayBuffer[A]()

  def suspend(): Unit = {
    broker.unsubscribe(this)
  }

  def activate(): Unit = {
    broker.subscribe(this)
  }

  override def handle(action: A): Unit = {
    buffer += action
  }

  /** Removes all actions in the buffer */
  def clear(): Unit = {
    buffer.clear()
  }

  /** Returns a vector of actions in the buffer and clears the buffer */
  def grab(): Vector[A] = {
    broker.waitForIncoming()
    val actions = buffer.toVector
    clear()
    actions
  }

  /** Returns a vector of actions contained in the buffer without clearing it */
  def list: Vector[A] = buffer.toVector
}
